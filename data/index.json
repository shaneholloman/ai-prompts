[
  {
    "name": "Appwrite Astro Setup",
    "description": "Guidelines for writing Astro apps with Appwrite authentication and database integration",
    "type": "setup",
    "slug": "appwrite-astro-setup",
    "development_process": [
      "implement"
    ],
    "dev_categories": [
      "frontend",
      "auth",
      "db"
    ],
    "tags": [
      "middleware"
    ],
    "tech_stack": {
      "framework": "astro",
      "service": "appwrite"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "setup-appwrite-astro.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-appwrite-astro-setup-appwrite-astro.md",
        "description": "Guidelines for writing Astro apps with Appwrite",
        "globs": "src/**/*.ts, src/**/*.astro",
        "content": "\n# Appwrite + Astro Integration Setup Guide\n\n## Prerequisites\n- Node.js and npm installed\n- Astro project initialized\n- Appwrite account and project created\n\n## Installation\n\nInstall required dependencies:\n```bash\nnpm install appwrite node-appwrite\nnpm install @astrojs/node\n```\n\nAdd Node adapter to Astro:\n```bash\nnpx astro add node\n```\n\n## Core Configuration\n\nCreate Appwrite client configuration (src/lib/appwrite.ts):\n```typescript\nimport { Client, Account, Databases, Storage } from 'appwrite';\n\nconst client = new Client()\n  .setEndpoint(import.meta.env.PUBLIC_APPWRITE_ENDPOINT || 'https://cloud.appwrite.io/v1')\n  .setProject(import.meta.env.PUBLIC_APPWRITE_PROJECT_ID || '');\n\nexport const account = new Account(client);\nexport const databases = new Databases(client);\nexport const storage = new Storage(client);\nexport default client;\n```\n\n## Authentication Implementation\n\nCreate middleware for session handling (src/middleware.ts):\n```typescript\nimport { defineMiddleware } from 'astro:middleware';\nimport { account } from './lib/appwrite';\n\nexport const onRequest = defineMiddleware(async ({ locals, cookies }, next) => {\n  const sessionId = cookies.get('sessionId')?.value;\n  \n  if (sessionId) {\n    try {\n      const user = await account.get();\n      locals.user = user;\n    } catch (error) {\n      cookies.delete('sessionId');\n      locals.user = null;\n    }\n  }\n  \n  return next();\n});\n```\n\n## Route Implementation Examples\n\nLogin Page (src/pages/login.astro):\n```astro\n---\nimport Layout from '../layouts/Layout.astro';\nimport { account } from '../lib/appwrite';\n\nlet error = null;\n\nif (Astro.request.method === 'POST') {\n  try {\n    const data = await Astro.request.formData();\n    const email = data.get('email')?.toString();\n    const password = data.get('password')?.toString();\n\n    if (email && password) {\n      const session = await account.createEmailSession(email, password);\n      Astro.cookies.set('sessionId', session.$id, {\n        httpOnly: true,\n        secure: import.meta.env.PROD,\n        sameSite: 'lax',\n        path: '/'\n      });\n      return Astro.redirect('/dashboard');\n    }\n  } catch (e) {\n    error = 'Invalid credentials';\n  }\n}\n---\n\n<Layout title=\"Login\">\n  <main>\n    <form method=\"POST\">\n      <div>\n        <label for=\"email\">Email</label>\n        <input type=\"email\" id=\"email\" name=\"email\" required />\n      </div>\n      <div>\n        <label for=\"password\">Password</label>\n        <input type=\"password\" id=\"password\" name=\"password\" required />\n      </div>\n      {error && <div class=\"error\">{error}</div>}\n      <button type=\"submit\">Login</button>\n    </form>\n  </main>\n</Layout>\n```\n\nProtected Dashboard Page (src/pages/dashboard.astro):\n```astro\n---\nimport Layout from '../layouts/Layout.astro';\nimport { databases } from '../lib/appwrite';\n\nif (!Astro.locals.user) {\n  return Astro.redirect('/login');\n}\n\nlet documents = [];\ntry {\n  const response = await databases.listDocuments(\n    'DATABASE_ID',\n    'COLLECTION_ID',\n    []\n  );\n  documents = response.documents;\n} catch (error) {\n  console.error('Failed to fetch documents:', error);\n}\n---\n\n<Layout title=\"Dashboard\">\n  <main>\n    <h1>Welcome, {Astro.locals.user.name}</h1>\n    <div class=\"documents\">\n      {documents.map(doc => (\n        <div class=\"document\" key={doc.$id}>\n          <h2>{doc.title}</h2>\n          <p>{doc.content}</p>\n        </div>\n      ))}\n    </div>\n  </main>\n</Layout>\n```\n\n## Security Guidelines\n\n1. Store sensitive configuration in environment variables\n2. Implement proper session management using secure cookies\n3. Set appropriate collection permissions in Appwrite Console\n4. Use API keys with minimal required scopes\n5. Enable HTTPS for production deployments\n\n## Implementation Guidelines\n\n1. Use server-side authentication with secure cookies\n2. Implement proper error handling and validation\n3. Create type definitions for Appwrite responses\n4. Keep Appwrite client configuration in server-only files\n5. Handle loading and error states consistently\n6. Use Astro's built-in form handling\n\n## Error Handling Example\n\nCreate an error component (src/components/ErrorBoundary.astro):\n```astro\n---\nconst { error } = Astro.props;\n---\n\n<div class=\"error-boundary\">\n  <h1>Error</h1>\n  <p>{error.message}</p>\n  <a href=\"/\">Return Home</a>\n</div>\n\n<style>\n  .error-boundary {\n    padding: 2rem;\n    text-align: center;\n  }\n</style>\n``` ",
        "filePath": "prompts/appwrite-astro/setup-appwrite-astro.md"
      }
    ],
    "filePath": "prompts/appwrite-astro/aiprompt.json"
  },
  {
    "name": "Drizzle Next.js Integration Setup",
    "description": "Guidelines for setting up and integrating Drizzle ORM with Next.js applications, including database configuration, server actions, client components, and best practices for security and performance.",
    "type": "setup",
    "slug": "drizzle-next-setup",
    "development_process": [
      "plan",
      "implement"
    ],
    "dev_categories": [
      "backend",
      "db"
    ],
    "tags": [
      "orm"
    ],
    "tech_stack": {
      "framework": "next",
      "service": "drizzle"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "setup-drizzle-next.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-drizzle-next-setup-drizzle-next.md",
        "description": "",
        "globs": "",
        "content": "# Drizzle ORM with Next.js Integration Setup Guide\n\nThis guide provides step-by-step instructions for integrating Drizzle ORM with a Next.js application.\n\n## Prerequisites\n- Node.js and npm installed\n- Next.js project initialized\n- PostgreSQL database (or any other supported database)\n\n## Installation\n\n1. Install Drizzle ORM and database driver:\n```bash\nnpm install drizzle-orm pg\nnpm install -D drizzle-kit @types/pg\n```\n\n2. For TypeScript support, ensure tsconfig.json includes:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2017\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ]\n  }\n}\n```\n\n## Database Configuration\n\n1. Create a database configuration file `src/db/config.ts`:\n```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { Pool } from 'pg';\n \nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n \nexport const db = drizzle(pool);\n```\n\n2. Create schema definition `src/db/schema.ts`:\n```typescript\nimport { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';\n \nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  email: text('email').notNull().unique(),\n  createdAt: timestamp('created_at').defaultNow(),\n});\n```\n\n3. Create migration configuration `drizzle.config.ts`:\n```typescript\nimport type { Config } from 'drizzle-kit';\n \nexport default {\n  schema: './src/db/schema.ts',\n  out: './drizzle',\n  driver: 'pg',\n  dbCredentials: {\n    connectionString: process.env.DATABASE_URL!,\n  },\n} satisfies Config;\n```\n\n4. Add migration scripts to package.json:\n```json\n{\n  \"scripts\": {\n    \"db:generate\": \"drizzle-kit generate:pg\",\n    \"db:push\": \"drizzle-kit push:pg\",\n    \"db:studio\": \"drizzle-kit studio\"\n  }\n}\n```\n\n## Server Actions Implementation\n\n1. Create a server action file `src/app/actions/users.ts`:\n```typescript\n'use server'\n \nimport { db } from '@/db/config';\nimport { users } from '@/db/schema';\nimport { eq } from 'drizzle-orm';\n \nexport async function getUsers() {\n  try {\n    return await db.select().from(users);\n  } catch (error) {\n    console.error('Failed to fetch users:', error);\n    throw error;\n  }\n}\n \nexport async function getUserById(id: number) {\n  try {\n    const [user] = await db\n      .select()\n      .from(users)\n      .where(eq(users.id, id));\n    return user;\n  } catch (error) {\n    console.error(`Failed to fetch user ${id}:`, error);\n    throw error;\n  }\n}\n \nexport async function createUser(data: { name: string; email: string }) {\n  try {\n    const [user] = await db\n      .insert(users)\n      .values(data)\n      .returning();\n    return user;\n  } catch (error) {\n    console.error('Failed to create user:', error);\n    throw error;\n  }\n}\n \nexport async function updateUser(id: number, data: { name?: string; email?: string }) {\n  try {\n    const [user] = await db\n      .update(users)\n      .set(data)\n      .where(eq(users.id, id))\n      .returning();\n    return user;\n  } catch (error) {\n    console.error(`Failed to update user ${id}:`, error);\n    throw error;\n  }\n}\n \nexport async function deleteUser(id: number) {\n  try {\n    await db\n      .delete(users)\n      .where(eq(users.id, id));\n  } catch (error) {\n    console.error(`Failed to delete user ${id}:`, error);\n    throw error;\n  }\n}\n```\n\n## Client Component Implementation\n\nCreate a client component `src/app/components/UserList.tsx`:\n```typescript\n'use client'\n \nimport { useEffect, useState } from 'react';\nimport { getUsers, createUser, updateUser, deleteUser } from '@/app/actions/users';\n \nexport default function UserList() {\n  const [users, setUsers] = useState([]);\n \n  useEffect(() => {\n    const loadUsers = async () => {\n      const data = await getUsers();\n      setUsers(data);\n    };\n    loadUsers();\n  }, []);\n \n  const handleCreateUser = async (e) => {\n    e.preventDefault();\n    const formData = new FormData(e.target);\n    await createUser({\n      name: formData.get('name') as string,\n      email: formData.get('email') as string,\n    });\n    const data = await getUsers();\n    setUsers(data);\n    e.target.reset();\n  };\n \n  return (\n    <div>\n      <form onSubmit={handleCreateUser}>\n        <input name=\"name\" placeholder=\"Name\" required />\n        <input name=\"email\" type=\"email\" placeholder=\"Email\" required />\n        <button type=\"submit\">Add User</button>\n      </form>\n \n      <ul>\n        {users.map((user) => (\n          <li key={user.id}>\n            {user.name} ({user.email})\n            <button onClick={() => deleteUser(user.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Environment Setup\n\n1. Create `.env.local` file:\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/dbname\n```\n\n2. Add `.env.local` to `.gitignore`:\n```\n.env.local\n```\n\n## Best Practices\n\n1. Database Connection\n   - Use connection pooling for better performance\n   - Keep environment variables secure\n   - Use migrations for schema changes\n\n2. Server Actions\n   - Implement proper error handling\n   - Use TypeScript for type safety\n   - Keep actions atomic and focused\n\n3. Client Components\n   - Implement proper loading states\n   - Handle errors gracefully\n   - Use optimistic updates when appropriate\n\n4. Security\n   - Validate input data\n   - Implement proper authentication\n   - Use prepared statements (handled by Drizzle)\n\n5. Performance\n   - Use indexes for frequently queried fields\n   - Implement pagination for large datasets\n   - Cache frequently accessed data\n\n## Migrations\n\n1. Generate migrations:\n```bash\nnpm run db:generate\n```\n\n2. Apply migrations:\n```bash\nnpm run db:push\n```\n\n3. View and manage database with Drizzle Studio:\n```bash\nnpm run db:studio\n``` ",
        "filePath": "prompts/drizzle-next/setup-drizzle-next.md"
      }
    ],
    "filePath": "prompts/drizzle-next/aiprompt.json"
  },
  {
    "name": "Drizzle Nuxt Integration Setup",
    "description": "Guidelines for setting up and integrating Drizzle ORM with Nuxt 3 applications",
    "type": "setup",
    "slug": "drizzle-nuxt-setup",
    "development_process": [
      "plan",
      "implement"
    ],
    "dev_categories": [
      "backend",
      "db"
    ],
    "tags": [
      "orm"
    ],
    "tech_stack": {
      "framework": "nuxt",
      "service": "drizzle"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "setup-drizzle-nuxt.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-drizzle-nuxt-setup-drizzle-nuxt.md",
        "description": "",
        "globs": "",
        "content": "# Drizzle + Nuxt Integration Setup Guide\n\nThis guide provides step-by-step instructions for integrating Drizzle ORM with a Nuxt 3 application.\n\n## Prerequisites\n- Node.js and npm installed\n- Nuxt 3 project initialized\n- PostgreSQL database (or any other supported database)\n\n## Installation\n\n1. Install required dependencies:\n```bash\nnpm install drizzle-orm pg\nnpm install -D drizzle-kit @types/pg\n```\n\n## Configuration\n\n1. Create a `.env` file in your project root:\n```env\nDATABASE_URL=postgres://<user>:<password>@<host>:<port>/<dbname>\n```\n\n2. Create a database schema file `server/db/schema.ts`:\n```typescript\nimport { pgTable, serial, text, varchar } from 'drizzle-orm/pg-core';\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  email: text('email').notNull().unique(),\n});\n\nexport type User = typeof users.$inferSelect;\nexport type NewUser = typeof users.$inferInsert;\n```\n\n3. Create a database configuration file `server/db/index.ts`:\n```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { Pool } from 'pg';\nimport * as schema from './schema';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool, { schema });\n```\n\n4. Create a migration script `drizzle.config.ts`:\n```typescript\nimport type { Config } from 'drizzle-kit';\n\nexport default {\n  schema: './server/db/schema.ts',\n  out: './drizzle',\n  driver: 'pg',\n  dbCredentials: {\n    connectionString: process.env.DATABASE_URL!,\n  },\n} satisfies Config;\n```\n\n5. Add migration scripts to `package.json`:\n```json\n{\n  \"scripts\": {\n    \"generate\": \"drizzle-kit generate:pg\",\n    \"migrate\": \"drizzle-kit push:pg\"\n  }\n}\n```\n\n## Usage Examples\n\n### Server Routes\n```typescript\n// server/api/users/index.ts\nimport { db } from '../../db';\nimport { users } from '../../db/schema';\nimport { eq } from 'drizzle-orm';\n\nexport default defineEventHandler(async (event) => {\n  const method = getMethod(event);\n\n  try {\n    switch (method) {\n      case 'GET':\n        return await db.select().from(users).orderBy(users.name);\n\n      case 'POST': {\n        const body = await readBody(event);\n        const [user] = await db\n          .insert(users)\n          .values(body)\n          .returning();\n        return user;\n      }\n\n      default:\n        throw createError({\n          statusCode: 405,\n          message: 'Method not allowed',\n        });\n    }\n  } catch (error: any) {\n    throw createError({\n      statusCode: 500,\n      message: error.message,\n    });\n  }\n});\n\n// server/api/users/[id].ts\nexport default defineEventHandler(async (event) => {\n  const method = getMethod(event);\n  const id = parseInt(event.context.params.id);\n\n  try {\n    switch (method) {\n      case 'GET': {\n        const [user] = await db\n          .select()\n          .from(users)\n          .where(eq(users.id, id));\n\n        if (!user) {\n          throw createError({\n            statusCode: 404,\n            message: 'User not found',\n          });\n        }\n\n        return user;\n      }\n\n      case 'PUT': {\n        const body = await readBody(event);\n        const [user] = await db\n          .update(users)\n          .set(body)\n          .where(eq(users.id, id))\n          .returning();\n\n        if (!user) {\n          throw createError({\n            statusCode: 404,\n            message: 'User not found',\n          });\n        }\n\n        return user;\n      }\n\n      case 'DELETE': {\n        await db.delete(users).where(eq(users.id, id));\n        return { success: true };\n      }\n\n      default:\n        throw createError({\n          statusCode: 405,\n          message: 'Method not allowed',\n        });\n    }\n  } catch (error: any) {\n    throw createError({\n      statusCode: 500,\n      message: error.message,\n    });\n  }\n});\n```\n\n### Composables\n```typescript\n// composables/useUsers.ts\nimport type { User, NewUser } from '~/server/db/schema';\n\nexport function useUsers() {\n  const users = ref<User[]>([]);\n  const loading = ref(false);\n  const error = ref<string | null>(null);\n\n  const fetchUsers = async () => {\n    loading.value = true;\n    error.value = null;\n    try {\n      users.value = await $fetch('/api/users');\n    } catch (e: any) {\n      error.value = e.message;\n    } finally {\n      loading.value = false;\n    }\n  };\n\n  const getUser = async (id: number) => {\n    loading.value = true;\n    error.value = null;\n    try {\n      return await $fetch(`/api/users/${id}`);\n    } catch (e: any) {\n      error.value = e.message;\n      throw e;\n    } finally {\n      loading.value = false;\n    }\n  };\n\n  const createUser = async (user: NewUser) => {\n    loading.value = true;\n    error.value = null;\n    try {\n      const newUser = await $fetch('/api/users', {\n        method: 'POST',\n        body: user,\n      });\n      users.value.push(newUser);\n      return newUser;\n    } catch (e: any) {\n      error.value = e.message;\n      throw e;\n    } finally {\n      loading.value = false;\n    }\n  };\n\n  const updateUser = async (id: number, user: Partial<NewUser>) => {\n    loading.value = true;\n    error.value = null;\n    try {\n      const updatedUser = await $fetch(`/api/users/${id}`, {\n        method: 'PUT',\n        body: user,\n      });\n      const index = users.value.findIndex(u => u.id === id);\n      if (index !== -1) {\n        users.value[index] = updatedUser;\n      }\n      return updatedUser;\n    } catch (e: any) {\n      error.value = e.message;\n      throw e;\n    } finally {\n      loading.value = false;\n    }\n  };\n\n  const deleteUser = async (id: number) => {\n    loading.value = true;\n    error.value = null;\n    try {\n      await $fetch(`/api/users/${id}`, { method: 'DELETE' });\n      users.value = users.value.filter(u => u.id !== id);\n    } catch (e: any) {\n      error.value = e.message;\n      throw e;\n    } finally {\n      loading.value = false;\n    }\n  };\n\n  return {\n    users,\n    loading,\n    error,\n    fetchUsers,\n    getUser,\n    createUser,\n    updateUser,\n    deleteUser,\n  };\n}\n```\n\n### Page Components\n```vue\n<!-- pages/users/index.vue -->\n<script setup lang=\"ts\">\nimport type { NewUser } from '~/server/db/schema';\n\nconst {\n  users,\n  loading,\n  error,\n  fetchUsers,\n  createUser,\n  deleteUser\n} = useUsers();\n\nconst newUser = ref<NewUser>({\n  name: '',\n  email: '',\n});\n\nonMounted(() => {\n  fetchUsers();\n});\n\nconst handleSubmit = async () => {\n  try {\n    await createUser(newUser.value);\n    newUser.value = { name: '', email: '' };\n  } catch (error) {\n    console.error('Failed to create user:', error);\n  }\n};\n</script>\n\n<template>\n  <div>\n    <h1>Users</h1>\n\n    <div v-if=\"loading\">Loading...</div>\n    <div v-else-if=\"error\" class=\"error\">{{ error }}</div>\n\n    <form @submit.prevent=\"handleSubmit\">\n      <input\n        v-model=\"newUser.name\"\n        placeholder=\"Name\"\n        required\n      />\n      <input\n        v-model=\"newUser.email\"\n        type=\"email\"\n        placeholder=\"Email\"\n        required\n      />\n      <button type=\"submit\">Add User</button>\n    </form>\n\n    <ul v-if=\"users.length\">\n      <li v-for=\"user in users\" :key=\"user.id\">\n        {{ user.name }} ({{ user.email }})\n        <button @click=\"deleteUser(user.id)\">Delete</button>\n      </li>\n    </ul>\n    <p v-else>No users found.</p>\n  </div>\n</template>\n\n<!-- pages/users/[id].vue -->\n<script setup lang=\"ts\">\nconst route = useRoute();\nconst router = useRouter();\n\nconst id = parseInt(route.params.id as string);\nconst { getUser, updateUser } = useUsers();\n\nconst user = ref(await getUser(id));\n\nconst handleSubmit = async (e: Event) => {\n  const form = e.target as HTMLFormElement;\n  const formData = new FormData(form);\n\n  try {\n    await updateUser(id, {\n      name: formData.get('name') as string,\n      email: formData.get('email') as string,\n    });\n    router.push('/users');\n  } catch (error) {\n    console.error('Failed to update user:', error);\n  }\n};\n</script>\n\n<template>\n  <div>\n    <h1>Edit User</h1>\n\n    <form @submit.prevent=\"handleSubmit\">\n      <input\n        name=\"name\"\n        :value=\"user.name\"\n        placeholder=\"Name\"\n        required\n      />\n      <input\n        name=\"email\"\n        type=\"email\"\n        :value=\"user.email\"\n        placeholder=\"Email\"\n        required\n      />\n      <button type=\"submit\">Update User</button>\n    </form>\n  </div>\n</template>\n```\n\n## Best Practices\n\n1. **Schema Management**\n   - Define schemas using Drizzle's type-safe builders\n   - Use migrations for schema changes\n   - Keep schema files organized and modular\n\n2. **Database Access**\n   - Keep database logic in server-side code\n   - Use typed queries with interfaces\n   - Implement proper error handling\n\n3. **Query Safety**\n   - Use Drizzle's query builders\n   - Validate input data before queries\n   - Implement proper error handling\n\n4. **Performance**\n   - Use connection pooling\n   - Implement pagination for large datasets\n   - Cache frequently accessed data\n\n5. **Type Safety**\n   - Use Drizzle's type inference\n   - Define proper interfaces\n   - Implement proper validation\n\n## Security Considerations\n\n1. **Database Access**\n   - Use least privilege database users\n   - Enable SSL for database connections\n   - Regularly rotate database credentials\n\n2. **Query Safety**\n   - Use Drizzle's query builders to prevent SQL injection\n   - Validate and sanitize all user inputs\n   - Implement rate limiting\n\n3. **Data Protection**\n   - Encrypt sensitive data\n   - Implement proper access controls\n   - Regular security audits\n\n## Troubleshooting\n\nCommon issues and solutions:\n\n1. **Connection Issues**\n   - Verify database URL format\n   - Check network connectivity\n   - Ensure SSL is properly configured\n\n2. **Migration Issues**\n   - Check schema syntax\n   - Verify migration files\n   - Run migrations in order\n\n3. **Performance Problems**\n   - Monitor query execution time\n   - Check for missing indexes\n   - Optimize large queries\n\n## Additional Resources\n\n- [Drizzle Documentation](https://orm.drizzle.team)\n- [Nuxt 3 Documentation](https://nuxt.com/docs)\n- [PostgreSQL Documentation](https://www.postgresql.org/docs/) ",
        "filePath": "prompts/drizzle-nuxt/setup-drizzle-nuxt.md"
      }
    ],
    "filePath": "prompts/drizzle-nuxt/aiprompt.json"
  },
  {
    "name": "Firebase Nuxt Integration Setup",
    "description": "Guidelines for setting up and integrating Firebase with Nuxt 3 applications",
    "type": "setup",
    "slug": "firebase-nuxt-setup",
    "development_process": [
      "implement",
      "test"
    ],
    "dev_categories": [
      "backend",
      "api",
      "db",
      "auth"
    ],
    "tags": [
      "realtime",
      "nosql"
    ],
    "tech_stack": {
      "framework": "nuxt",
      "service": "firebase"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "setup-firebase-nuxt.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-firebase-nuxt-setup-firebase-nuxt.md",
        "description": "",
        "globs": "",
        "content": "# Firebase + Nuxt Integration Setup Guide\n\nThis guide provides step-by-step instructions for integrating Firebase with Nuxt 3 using VueFire.\n\n## Prerequisites\n- Node.js and npm installed\n- Nuxt 3 project set up\n- Firebase account and project created\n- Basic understanding of Nuxt and Firebase\n\n## Installation\n\n1. Install required dependencies:\n```bash\nnpm install firebase nuxt-vuefire\n```\n\n2. Configure Nuxt and Firebase in `nuxt.config.ts`:\n```typescript\nexport default defineNuxtConfig({\n  modules: ['nuxt-vuefire'],\n  vuefire: {\n    config: {\n      apiKey: process.env.FIREBASE_API_KEY,\n      authDomain: process.env.FIREBASE_AUTH_DOMAIN,\n      projectId: process.env.FIREBASE_PROJECT_ID,\n      storageBucket: process.env.FIREBASE_STORAGE_BUCKET,\n      messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,\n      appId: process.env.FIREBASE_APP_ID\n    },\n    auth: {\n      enabled: true,\n      sessionCookie: true // Enable server-side auth\n    },\n    admin: {\n      // Optional: Enable Firebase Admin for server-side operations\n      serviceAccount: {\n        projectId: process.env.FIREBASE_ADMIN_PROJECT_ID,\n        clientEmail: process.env.FIREBASE_ADMIN_CLIENT_EMAIL,\n        privateKey: process.env.FIREBASE_ADMIN_PRIVATE_KEY\n      }\n    }\n  },\n  runtimeConfig: {\n    public: {\n      firebaseApiKey: process.env.FIREBASE_API_KEY,\n      firebaseAuthDomain: process.env.FIREBASE_AUTH_DOMAIN,\n      firebaseProjectId: process.env.FIREBASE_PROJECT_ID,\n      firebaseStorageBucket: process.env.FIREBASE_STORAGE_BUCKET,\n      firebaseMessagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,\n      firebaseAppId: process.env.FIREBASE_APP_ID\n    }\n  }\n})\n```\n\n3. Create `.env` file:\n```env\nFIREBASE_API_KEY=your-api-key\nFIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com\nFIREBASE_PROJECT_ID=your-project-id\nFIREBASE_STORAGE_BUCKET=your-project.appspot.com\nFIREBASE_MESSAGING_SENDER_ID=your-messaging-sender-id\nFIREBASE_APP_ID=your-app-id\n\n# Optional: Firebase Admin SDK credentials\nFIREBASE_ADMIN_PROJECT_ID=your-project-id\nFIREBASE_ADMIN_CLIENT_EMAIL=your-client-email\nFIREBASE_ADMIN_PRIVATE_KEY=your-private-key\n```\n\n## Usage Examples\n\n### Authentication Composable\n\n1. Create `composables/useFirebaseAuth.ts`:\n```typescript\nimport { useFirebaseAuth, useCurrentUser } from 'vuefire'\nimport {\n  signInWithEmailAndPassword,\n  createUserWithEmailAndPassword,\n  signInWithPopup,\n  GoogleAuthProvider,\n  signOut as firebaseSignOut,\n  onAuthStateChanged,\n  type User\n} from 'firebase/auth'\n\nexport function useAuth() {\n  const auth = useFirebaseAuth()!\n  const user = useCurrentUser()\n  const router = useRouter()\n  const loading = ref(false)\n  const error = ref<string | null>(null)\n\n  // Email/Password Sign In\n  const signInWithEmail = async (email: string, password: string) => {\n    loading.value = true\n    error.value = null\n    try {\n      await signInWithEmailAndPassword(auth, email, password)\n      router.push('/dashboard')\n    } catch (e: any) {\n      error.value = e.message\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Email/Password Sign Up\n  const signUpWithEmail = async (email: string, password: string) => {\n    loading.value = true\n    error.value = null\n    try {\n      await createUserWithEmailAndPassword(auth, email, password)\n      router.push('/dashboard')\n    } catch (e: any) {\n      error.value = e.message\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Google Sign In\n  const signInWithGoogle = async () => {\n    loading.value = true\n    error.value = null\n    try {\n      const provider = new GoogleAuthProvider()\n      await signInWithPopup(auth, provider)\n      router.push('/dashboard')\n    } catch (e: any) {\n      error.value = e.message\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // Sign Out\n  const signOut = async () => {\n    loading.value = true\n    error.value = null\n    try {\n      await firebaseSignOut(auth)\n      router.push('/')\n    } catch (e: any) {\n      error.value = e.message\n    } finally {\n      loading.value = false\n    }\n  }\n\n  return {\n    user,\n    loading,\n    error,\n    signInWithEmail,\n    signUpWithEmail,\n    signInWithGoogle,\n    signOut\n  }\n}\n```\n\n### Firestore Composables\n\n1. Create `composables/useFirestore.ts`:\n```typescript\nimport { useFirestore, useCollection, useDocument } from 'vuefire'\nimport {\n  collection,\n  doc,\n  query,\n  where,\n  orderBy,\n  limit,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  type DocumentData,\n  type QueryConstraint\n} from 'firebase/firestore'\n\nexport function useFirestoreCollection<T = DocumentData>(\n  path: string,\n  constraints?: {\n    where?: [string, firebase.firestore.WhereFilterOp, any][];\n    orderBy?: [string, 'asc' | 'desc'][];\n    limit?: number;\n  }\n) {\n  const db = useFirestore()\n  const loading = ref(false)\n  const error = ref<string | null>(null)\n\n  const buildQuery = () => {\n    let collectionRef = collection(db, path)\n    const queryConstraints: QueryConstraint[] = []\n\n    if (constraints) {\n      if (constraints.where) {\n        constraints.where.forEach(([field, op, value]) => {\n          queryConstraints.push(where(field, op, value))\n        })\n      }\n\n      if (constraints.orderBy) {\n        constraints.orderBy.forEach(([field, direction]) => {\n          queryConstraints.push(orderBy(field, direction))\n        })\n      }\n\n      if (constraints.limit) {\n        queryConstraints.push(limit(constraints.limit))\n      }\n    }\n\n    return queryConstraints.length > 0\n      ? query(collectionRef, ...queryConstraints)\n      : collectionRef\n  }\n\n  const data = useCollection<T>(buildQuery())\n\n  const add = async (document: Omit<T, 'id'>) => {\n    loading.value = true\n    error.value = null\n    try {\n      const docRef = await addDoc(collection(db, path), document)\n      return docRef.id\n    } catch (e: any) {\n      error.value = e.message\n      throw e\n    } finally {\n      loading.value = false\n    }\n  }\n\n  return {\n    data,\n    loading,\n    error,\n    add\n  }\n}\n\nexport function useFirestoreDocument<T = DocumentData>(path: string, id: string) {\n  const db = useFirestore()\n  const loading = ref(false)\n  const error = ref<string | null>(null)\n\n  const docRef = doc(db, path, id)\n  const data = useDocument<T>(docRef)\n\n  const update = async (updates: Partial<T>) => {\n    loading.value = true\n    error.value = null\n    try {\n      await updateDoc(docRef, updates as DocumentData)\n    } catch (e: any) {\n      error.value = e.message\n      throw e\n    } finally {\n      loading.value = false\n    }\n  }\n\n  const remove = async () => {\n    loading.value = true\n    error.value = null\n    try {\n      await deleteDoc(docRef)\n    } catch (e: any) {\n      error.value = e.message\n      throw e\n    } finally {\n      loading.value = false\n    }\n  }\n\n  return {\n    data,\n    loading,\n    error,\n    update,\n    remove\n  }\n}\n```\n\n### Storage Composable\n\n1. Create `composables/useStorage.ts`:\n```typescript\nimport { useFirebaseStorage } from 'vuefire'\nimport {\n  ref as storageRef,\n  uploadBytes,\n  getDownloadURL,\n  deleteObject\n} from 'firebase/storage'\n\nexport function useStorage(path: string) {\n  const storage = useFirebaseStorage()!\n  const loading = ref(false)\n  const error = ref<string | null>(null)\n  const downloadURL = ref<string | null>(null)\n\n  const upload = async (file: File) => {\n    loading.value = true\n    error.value = null\n    try {\n      const fileRef = storageRef(storage, `${path}/${file.name}`)\n      await uploadBytes(fileRef, file)\n      downloadURL.value = await getDownloadURL(fileRef)\n      return downloadURL.value\n    } catch (e: any) {\n      error.value = e.message\n      throw e\n    } finally {\n      loading.value = false\n    }\n  }\n\n  const remove = async (filename: string) => {\n    loading.value = true\n    error.value = null\n    try {\n      const fileRef = storageRef(storage, `${path}/${filename}`)\n      await deleteObject(fileRef)\n      downloadURL.value = null\n    } catch (e: any) {\n      error.value = e.message\n      throw e\n    } finally {\n      loading.value = false\n    }\n  }\n\n  return {\n    loading,\n    error,\n    downloadURL,\n    upload,\n    remove\n  }\n}\n```\n\n### Example Components\n\n1. Authentication Component:\n```vue\n<!-- components/Auth.vue -->\n<template>\n  <div>\n    <div v-if=\"error\" class=\"error\">{{ error }}</div>\n    \n    <form @submit.prevent=\"handleSubmit\" v-if=\"!user\">\n      <input\n        v-model=\"email\"\n        type=\"email\"\n        placeholder=\"Email\"\n        required\n      />\n      <input\n        v-model=\"password\"\n        type=\"password\"\n        placeholder=\"Password\"\n        required\n      />\n      <button type=\"submit\" :disabled=\"loading\">\n        {{ isSignUp ? 'Sign Up' : 'Sign In' }}\n      </button>\n      <button\n        type=\"button\"\n        @click=\"signInWithGoogle\"\n        :disabled=\"loading\"\n      >\n        Sign in with Google\n      </button>\n      <a href=\"#\" @click.prevent=\"isSignUp = !isSignUp\">\n        {{ isSignUp ? 'Already have an account?' : 'Need an account?' }}\n      </a>\n    </form>\n\n    <div v-else>\n      <p>Welcome, {{ user.email }}</p>\n      <button @click=\"signOut\" :disabled=\"loading\">Sign Out</button>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nconst {\n  user,\n  loading,\n  error,\n  signInWithEmail,\n  signUpWithEmail,\n  signInWithGoogle,\n  signOut\n} = useAuth()\n\nconst email = ref('')\nconst password = ref('')\nconst isSignUp = ref(false)\n\nconst handleSubmit = async () => {\n  if (isSignUp.value) {\n    await signUpWithEmail(email.value, password.value)\n  } else {\n    await signInWithEmail(email.value, password.value)\n  }\n}\n</script>\n```\n\n2. Firestore CRUD Component:\n```vue\n<!-- components/TodoList.vue -->\n<template>\n  <div>\n    <div v-if=\"error\" class=\"error\">{{ error }}</div>\n\n    <form @submit.prevent=\"handleSubmit\">\n      <input\n        v-model=\"newTodo\"\n        type=\"text\"\n        placeholder=\"New todo\"\n        required\n      />\n      <button type=\"submit\" :disabled=\"loading\">Add Todo</button>\n    </form>\n\n    <ul v-if=\"todos.data\">\n      <li v-for=\"todo in todos.data\" :key=\"todo.id\">\n        <span>{{ todo.text }}</span>\n        <button\n          @click=\"deleteTodo(todo.id)\"\n          :disabled=\"loading\"\n        >\n          Delete\n        </button>\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\ninterface Todo {\n  id: string\n  text: string\n  completed: boolean\n  createdAt: Date\n}\n\nconst newTodo = ref('')\nconst todos = useFirestoreCollection<Todo>('todos', {\n  orderBy: [['createdAt', 'desc']]\n})\n\nconst handleSubmit = async () => {\n  if (!newTodo.value.trim()) return\n\n  await todos.add({\n    text: newTodo.value,\n    completed: false,\n    createdAt: new Date()\n  })\n\n  newTodo.value = ''\n}\n\nconst deleteTodo = async (id: string) => {\n  const todo = useFirestoreDocument<Todo>('todos', id)\n  await todo.remove()\n}\n</script>\n```\n\n## Server-Side Usage\n\n1. Create server middleware for authentication:\n```typescript\n// server/middleware/auth.ts\nexport default defineEventHandler(async (event) => {\n  const session = await getUserSession(event)\n  if (!session && !event.path.startsWith('/api/public')) {\n    throw createError({\n      statusCode: 401,\n      message: 'Unauthorized'\n    })\n  }\n})\n```\n\n2. Create API routes with Firebase Admin:\n```typescript\n// server/api/users/[id].ts\nimport { getFirestore } from 'firebase-admin/firestore'\n\nexport default defineEventHandler(async (event) => {\n  const id = event.context.params.id\n  const db = getFirestore()\n  \n  try {\n    const doc = await db.collection('users').doc(id).get()\n    if (!doc.exists) {\n      throw createError({\n        statusCode: 404,\n        message: 'User not found'\n      })\n    }\n    return { id: doc.id, ...doc.data() }\n  } catch (error: any) {\n    throw createError({\n      statusCode: 500,\n      message: error.message\n    })\n  }\n})\n```\n\n## Security Considerations\n1. Use environment variables for Firebase configuration\n2. Implement proper Firebase security rules\n3. Enable App Check for additional security\n4. Use server-side session cookies for authentication\n5. Validate data on both client and server\n6. Implement rate limiting\n7. Use Firebase Admin SDK for server-side operations\n\n## Best Practices\n1. Use composables for Firebase services\n2. Implement proper error handling\n3. Use TypeScript for better type safety\n4. Follow Nuxt 3 conventions\n5. Implement proper loading states\n6. Use Firebase emulators for development\n7. Keep Firebase configuration secure\n8. Use proper data validation\n\n## Troubleshooting\n1. Check Nuxt server logs\n2. Monitor Firebase console\n3. Verify security rules\n4. Check network requests\n5. Validate environment variables\n6. Check Firebase emulator\n7. Verify authentication state\n\n## Additional Resources\n- [Nuxt 3 Documentation](https://nuxt.com/docs)\n- [VueFire Documentation](https://vuefire.vuejs.org/)\n- [Firebase Documentation](https://firebase.google.com/docs)\n- [Firebase Console](https://console.firebase.google.com/) ",
        "filePath": "prompts/firebase-nuxt/setup-firebase-nuxt.md"
      }
    ],
    "filePath": "prompts/firebase-nuxt/aiprompt.json"
  },
  {
    "name": "Neon Remix Integration Setup",
    "description": "Guidelines for setting up and integrating Neon serverless Postgres with Remix applications",
    "type": "setup",
    "slug": "neon-remix-setup",
    "development_process": [
      "implement",
      "test"
    ],
    "dev_categories": [
      "backend",
      "db"
    ],
    "tags": [
      "serverless"
    ],
    "tech_stack": {
      "framework": "remix",
      "service": "neon"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "setup-neon-remix.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-neon-remix-setup-neon-remix.md",
        "description": "",
        "globs": "",
        "content": "# Neon + Remix Integration Setup Guide\n\nThis guide provides step-by-step instructions for integrating Neon serverless Postgres with a Remix application.\n\n## Prerequisites\n- Node.js and npm installed\n- Remix project initialized\n- Neon account and project created\n\n## Installation\n\n1. Install required dependencies:\n```bash\nnpm install @neondatabase/serverless\n```\n\n## Configuration\n\n1. Create a `.env` file in your project root:\n```env\nDATABASE_URL=postgresql://<user>:<password>@<endpoint>.neon.tech/<dbname>?sslmode=require\n```\n\n2. Create a database configuration file `app/lib/db.server.ts`:\n```typescript\nimport { neon } from '@neondatabase/serverless';\n\nconst sql = neon(process.env.DATABASE_URL!);\n\nexport { sql };\n```\n\n## Usage Examples\n\n### Basic Database Operations\n```typescript\n// app/routes/users.tsx\nimport { json, type LoaderFunctionArgs } from '@remix-run/node';\nimport { useLoaderData } from '@remix-run/react';\nimport { sql } from '~/lib/db.server';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  try {\n    const users = await sql<User[]>`\n      SELECT id, name, email\n      FROM users\n      ORDER BY name ASC\n    `;\n    return json({ users });\n  } catch (error: any) {\n    throw new Error(`Failed to fetch users: ${error.message}`);\n  }\n}\n\nexport async function action({ request }: LoaderFunctionArgs) {\n  const formData = await request.formData();\n  const action = formData.get('action');\n\n  try {\n    switch (action) {\n      case 'create': {\n        const name = formData.get('name') as string;\n        const email = formData.get('email') as string;\n\n        const [user] = await sql<User[]>`\n          INSERT INTO users (name, email)\n          VALUES (${name}, ${email})\n          RETURNING id, name, email\n        `;\n        return json({ user });\n      }\n\n      case 'update': {\n        const id = parseInt(formData.get('id') as string);\n        const name = formData.get('name') as string;\n        const email = formData.get('email') as string;\n\n        const [user] = await sql<User[]>`\n          UPDATE users\n          SET name = ${name}, email = ${email}\n          WHERE id = ${id}\n          RETURNING id, name, email\n        `;\n        return json({ user });\n      }\n\n      case 'delete': {\n        const id = parseInt(formData.get('id') as string);\n        await sql`DELETE FROM users WHERE id = ${id}`;\n        return json({ success: true });\n      }\n\n      default:\n        throw new Error('Invalid action');\n    }\n  } catch (error: any) {\n    throw new Error(`Failed to perform action: ${error.message}`);\n  }\n}\n\nexport default function Users() {\n  const { users } = useLoaderData<typeof loader>();\n\n  return (\n    <div>\n      <h1>Users</h1>\n\n      <form method=\"post\">\n        <input type=\"hidden\" name=\"action\" value=\"create\" />\n        <input type=\"text\" name=\"name\" placeholder=\"Name\" required />\n        <input type=\"email\" name=\"email\" placeholder=\"Email\" required />\n        <button type=\"submit\">Add User</button>\n      </form>\n\n      <ul>\n        {users.map((user) => (\n          <li key={user.id}>\n            <form method=\"post\" style={{ display: 'inline' }}>\n              <input type=\"hidden\" name=\"action\" value=\"delete\" />\n              <input type=\"hidden\" name=\"id\" value={user.id} />\n              <span>{user.name} ({user.email})</span>\n              <button type=\"submit\">Delete</button>\n            </form>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### Database Utility Functions\n```typescript\n// app/lib/db.utils.server.ts\nimport { sql } from './db.server';\n\nexport async function withTransaction<T>(\n  callback: (transaction: typeof sql) => Promise<T>\n): Promise<T> {\n  try {\n    await sql`BEGIN`;\n    const result = await callback(sql);\n    await sql`COMMIT`;\n    return result;\n  } catch (error) {\n    await sql`ROLLBACK`;\n    throw error;\n  }\n}\n\nexport async function createPaginatedQuery<T>(\n  baseQuery: string,\n  page: number,\n  pageSize: number,\n  params: any[] = []\n): Promise<{ data: T[]; total: number; pages: number }> {\n  const offset = (page - 1) * pageSize;\n  const countQuery = `SELECT COUNT(*) as total FROM (${baseQuery}) as subquery`;\n  \n  const [{ total }] = await sql.raw(countQuery, params);\n  const data = await sql.raw<T[]>(\n    `${baseQuery} LIMIT ${pageSize} OFFSET ${offset}`,\n    params\n  );\n\n  return {\n    data,\n    total: parseInt(total),\n    pages: Math.ceil(total / pageSize)\n  };\n}\n\nexport async function executeInBatch<T>(\n  items: T[],\n  batchSize: number,\n  callback: (batch: T[]) => Promise<void>\n): Promise<void> {\n  for (let i = 0; i < items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize);\n    await callback(batch);\n  }\n}\n```\n\n## Best Practices\n\n1. **Environment Configuration**\n   - Use environment variables for database credentials\n   - Never commit sensitive credentials to version control\n   - Use different database branches for development/production\n\n2. **Database Access**\n   - Keep database logic in server-only files (*.server.ts)\n   - Use typed queries with interfaces\n   - Implement proper error handling\n\n3. **Query Safety**\n   - Use parameterized queries to prevent SQL injection\n   - Validate input data before queries\n   - Implement proper error handling\n\n4. **Performance**\n   - Use connection pooling when possible\n   - Implement pagination for large datasets\n   - Cache frequently accessed data\n\n5. **Type Safety**\n   - Define interfaces for database models\n   - Use TypeScript's strict mode\n   - Implement proper data validation\n\n## Security Considerations\n\n1. **Database Access**\n   - Use least privilege database users\n   - Enable SSL for database connections\n   - Regularly rotate database credentials\n\n2. **Query Safety**\n   - Always use parameterized queries\n   - Validate and sanitize all user inputs\n   - Implement rate limiting\n\n3. **Data Protection**\n   - Encrypt sensitive data\n   - Implement proper access controls\n   - Regular security audits\n\n## Troubleshooting\n\nCommon issues and solutions:\n\n1. **Connection Issues**\n   - Verify database URL format\n   - Check network connectivity\n   - Ensure SSL is properly configured\n\n2. **Query Errors**\n   - Check SQL syntax\n   - Verify table and column names\n   - Validate data types\n\n3. **Performance Problems**\n   - Monitor query execution time\n   - Check for missing indexes\n   - Optimize large queries\n\n## Additional Resources\n\n- [Neon Documentation](https://neon.tech/docs)\n- [Remix Documentation](https://remix.run/docs)\n- [TypeScript Documentation](https://www.typescriptlang.org/) ",
        "filePath": "prompts/neon-remix/setup-neon-remix.md"
      }
    ],
    "filePath": "prompts/neon-remix/aiprompt.json"
  },
  {
    "name": "Next.js 15 Coding Standards",
    "description": "Comprehensive coding standards and best practices for Next.js 15 development, covering project structure, TypeScript usage, and more",
    "type": "rule",
    "slug": "next-coding-standards",
    "development_process": [
      "plan",
      "implement"
    ],
    "dev_categories": [
      "frontend",
      "documentation"
    ],
    "tags": [
      "architecture"
    ],
    "tech_stack": {
      "framework": "next"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "rule-next-coding-standards.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-next-15-rule-next-coding-standards.md",
        "description": "Coding Standards & Rules for Nextjs 15 and React 19",
        "globs": "**/*.tsx, **/*.ts, **/*.js, **/*.jsx",
        "content": "\n# Project Structure And App Router\n\n- Use the App Router (`app` directory) in Next.js 15\n- Co-locate route handlers, loading and error states, and page-level components within the `app` directory\n- Use route groups (parentheses) to organize without affecting URLs\n- Use parallel or intercepting routes for complex layouts and modals\n- Place API route handlers in `app/api`\n\n# Server Components\n\n- Default to Server Components for data fetching and rendering\n- Keep them free of client-side hooks or browser APIs\n- Use `Suspense` boundaries for streaming and granular loading states\n- Use `generateMetadata` in `layout.tsx` or `page.tsx` for dynamic SEO metadata\n- Prefer `fetch` with `revalidate` options for caching in Server Components\n- Implement `generateStaticParams` for static builds of dynamic routes\n- Use `unstable_noStore` for fully dynamic, non-cached rendering\n- Use `Promise.all` for parallel data fetching and `React.cache` for request deduplication\n\n# Client Components\n\n- Mark Client Components with `\"use client\"` at the top\n- Use `next/navigation` hooks such as `useRouter` and `usePathname` instead of `next/router`\n- Handle form state with `useFormStatus`, `useFormState`, and `useOptimistic` when using Server Actions\n- Include client-specific logic like user interaction and browser APIs here\n\n# Data Fetching\n\n- Use the built-in `fetch` in Server Components for data retrieval\n- Pass caching strategies with `fetch(url, { next: { revalidate: <seconds> } })`\n- Keep external requests minimal if deploying to serverless environments\n- Avoid fetching in Client Components if it can be done on the server\n\n# Route Handlers\n\n- Replace deprecated `pages/api` routes with Route Handlers under `app/api`\n- `GET` handlers are static by default unless otherwise configured\n- Validate incoming data and use proper CORS or security measures\n- Support JSON, text, and other file responses\n\n# Server Actions\n\n- Define Server Actions with the `use server` directive\n- Call them from both Server and Client Components for data mutations\n- Use `useFormStatus` and `useFormState` in Client Components to track form submissions\n- Use `useOptimistic` to update the UI optimistically before server confirmation\n\n# Middleware And Edge Runtime\n\n- Use `middleware.ts` for route interception, authentication, redirects, and rewrites\n- Use the Edge Runtime for faster startup and location-based personalization\n- Handle cookies, headers, and dynamic rewrites in `middleware`\n- Be mindful of constraints when running at the edge\n\n# Styling And Assets\n\n- Use CSS Modules, Tailwind CSS, or CSS-in-JS solutions\n- Use the built-in `<Image />` component for optimized images\n- Consider built-in font optimization with `@next/font` or newer APIs\n\n# Performance\n\n- Use streaming and `Suspense` for faster initial rendering\n- Dynamically import large dependencies in Client Components\n- Use `React.useMemo` and `React.useCallback` in Client Components to avoid re-renders\n- Use `fetch` caching and revalidation carefully\n\n# Deployment\n\n- Use Vercel for integrated features or self-host with Node or Docker\n- Test SSR and static outputs thoroughly\n- Keep environment variables secure, never expose private values on the client\n\n# Testing And Linting\n\n- Use `next lint` with ESLint and integrate Prettier\n- Use Jest, React Testing Library, or Cypress for testing\n- Keep test files near related components\n\n# Dos\n\n- Do organize routes and components in the `app` directory\n- Do leverage Server Components for data fetching\n- Do use Server Actions for form submissions\n- Do use `next/link` for internal routing and prefetching\n- Do implement loading states with `loading` files\n- Do optimize images with the `<Image />` component\n- Do separate server and client logic carefully\n\n# Donts\n\n- Dont mix the `pages` and `app` directories for routing\n- Dont fetch data in Client Components if it can be done on the server\n- Dont use `router.push` for form submissions when Server Actions are available\n- Never expose sensitive environment variables in client code\n- Dont import client-only modules into Server Components\n- Avoid using `next/router` in App Router projects\n",
        "filePath": "prompts/next-15/rule-next-coding-standards.md"
      }
    ],
    "filePath": "prompts/next-15/aiprompt.json"
  },
  {
    "name": "Next.js 15 Feature Guidelines",
    "description": "Comprehensive guidelines for adding new features in Next.js 15 applications, covering pages, components, and API routes",
    "type": "feature",
    "slug": "next-feature-guidelines",
    "development_process": [
      "plan",
      "implement",
      "test"
    ],
    "dev_categories": [
      "frontend",
      "api"
    ],
    "tags": [
      "server-components"
    ],
    "tech_stack": {
      "framework": "next"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "add-feature-next.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-next-15-add-feature-next.md",
        "description": "Guidelines for adding new features in Next.js 15 applications",
        "globs": "**/*.tsx, **/*.ts",
        "content": "\nYou are a senior Next.js 15 developer with expertise in building scalable applications.\n\n# App Router Features\n- Use server components by default. Example: app/products/page.tsx\n- Implement parallel routes. Example: app/@modal/login/page.tsx\n- Use intercepting routes. Example: app/feed/(..)photo/[id]/page.tsx\n- Implement route groups. Example: app/(auth)/login/page.tsx\n- Use loading states with suspense. Example: app/products/loading.tsx\n\n# Data Fetching\n- Use server-side data fetching with caching. Example:\n```typescript\nasync function getProduct(id: string) {\n  const res = await fetch(`/api/products/${id}`, { \n    next: { revalidate: 3600 } \n  })\n  return res.json()\n}\n```\n\n- Implement streaming with suspense. Example:\n```typescript\nimport { Suspense } from 'react'\n\nexport default function Page() {\n  return (\n    <Suspense fallback={<ProductSkeleton />}>\n      <ProductInfo />\n    </Suspense>\n  )\n}\n```\n\n- Use parallel data fetching. Example:\n```typescript\nasync function ProductPage() {\n  const [product, reviews] = await Promise.all([\n    getProduct(id),\n    getProductReviews(id)\n  ])\n  return <ProductDetails product={product} reviews={reviews} />\n}\n```\n\n# Server Actions\n- Use form actions for mutations. Example:\n```typescript\nexport default function AddToCart() {\n  async function addItem(formData: FormData) {\n    'use server'\n    const id = formData.get('productId')\n    await db.cart.add({ productId: id })\n    revalidatePath('/cart')\n  }\n  \n  return (\n    <form action={addItem}>\n      <input name=\"productId\" type=\"hidden\" value=\"123\" />\n      <button type=\"submit\">Add to Cart</button>\n    </form>\n  )\n}\n```\n\n# Component Architecture\n- Use client components when needed. Example:\n```typescript\n'use client'\n\nexport function InteractiveButton({ onClick }: { onClick: () => void }) {\n  const [isLoading, setLoading] = useState(false)\n  \n  return (\n    <button \n      onClick={async () => {\n        setLoading(true)\n        await onClick()\n        setLoading(false)\n      }}\n      disabled={isLoading}\n    >\n      {isLoading ? 'Loading...' : 'Click me'}\n    </button>\n  )\n}\n```\n\n# Server Components\n- Create type-safe server components. Example:\n```typescript\ninterface ProductGridProps {\n  category: string\n  sort?: 'asc' | 'desc'\n}\n\nexport async function ProductGrid({ category, sort }: ProductGridProps) {\n  const products = await db.products.findMany({\n    where: { category },\n    orderBy: { price: sort }\n  })\n  \n  return (\n    <div className=\"grid grid-cols-3 gap-4\">\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  )\n}\n```\n\n# API Routes\n- Use route handlers with proper types. Example:\n```typescript\nimport { NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  const { searchParams } = request.nextUrl\n  const query = searchParams.get('q')\n  \n  const products = await db.products.search(query)\n  return Response.json(products)\n}\n```\n\n# Performance Features\n- Use image optimization. Example: <Image src={src} width={300} height={200} alt=\"Product\" />\n- Implement route prefetching. Example: <Link href=\"/products\" prefetch={true}>Products</Link>\n- Use React Suspense for code splitting. Example: const Modal = lazy(() => import('./Modal'))\n- Implement proper caching strategies. Example: export const revalidate = 3600\n- Use streaming for large lists. Example: <Suspense><ProductStream /></Suspense>\n\n# Metadata\n- Use dynamic metadata generation. Example:\n```typescript\nexport async function generateMetadata({ params }: Props) {\n  const product = await getProduct(params.id)\n  \n  return {\n    title: product.name,\n    description: product.description,\n    openGraph: {\n      images: [{ url: product.image }]\n    }\n  }\n}\n```\n\n# Error Handling\n- Use error boundaries effectively. Example: app/products/[id]/error.tsx\n- Implement not-found pages. Example: app/products/[id]/not-found.tsx\n- Use loading states. Example: app/products/loading.tsx\n- Implement global error handling. Example: app/global-error.tsx\n- Use proper API error responses\n\n# SEO Features\n- Use metadata API for SEO. Example:\n```typescript\nexport const metadata = {\n  title: 'Product Catalog',\n  description: 'Browse our products',\n  robots: {\n    index: true,\n    follow: true\n  }\n}\n```\n- Implement dynamic sitemap generation\n- Use proper canonical URLs\n- Implement JSON-LD structured data\n- Use proper OpenGraph tags",
        "filePath": "prompts/next-15/add-feature-next.md"
      }
    ],
    "filePath": "prompts/next-15/aiprompt.json"
  },
  {
    "name": "Nuxt 3 Coding Standards",
    "description": "Comprehensive coding standards and best practices for Nuxt 3 development, covering project structure, TypeScript usage, and more",
    "type": "rule",
    "slug": "nuxt-coding-standards",
    "development_process": [
      "plan",
      "implement"
    ],
    "dev_categories": [
      "frontend",
      "documentation"
    ],
    "tags": [
      "architecture"
    ],
    "tech_stack": {
      "framework": "nuxt"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "rule-nuxt-coding-standards.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-nuxt-3-rule-nuxt-coding-standards.md",
        "description": "Framework-specific coding standards for Nuxt 3 applications",
        "globs": "**/*.vue, **/*.ts, **/*.js",
        "content": "\nYou are a senior Nuxt 3 developer with extensive expertise in modern Nuxt development, TypeScript, and web development best practices for 2025. Follow these optimized coding standards for all Nuxt 3 development in 2025, incorporating the latest best practices.\n\n# Project Structure\n- Maintain Nuxt's directory-based structure for clarity and convention.\n- Organize components within `components/`, categorized by feature or domain.\n- Place pages in `pages/` to leverage Nuxt's file-based routing.\n- Store composables in `composables/` for reusable logic.\n- Keep layouts in `layouts/` for consistent page structures.\n- Place middleware in `middleware/` for route-level logic.\n- Store plugins in `plugins/` for Vue and Nuxt extensions.\n- Keep API routes in `server/api/` for backend functionality.\n- Place utilities in `utils/` or `lib/` for helper functions.\n- Store static assets in `public/`.\n\n# Code Style\n- Use TypeScript consistently for type safety and maintainability.\n- Prefer `<script setup>` syntax for concise and performant components.\n- Follow Vue 3 Composition API for all component logic.\n- Adhere to PascalCase for component filenames and names (e.g., `MyComponent.vue`).\n- Use kebab-case for directories and other non-component filenames.\n\n# TypeScript Usage\n- Enforce strict mode in TypeScript configuration.\n- Define explicit types for component props, composables, and API responses.\n- Avoid `any` type; utilize generics for reusable and type-safe code.\n- Leverage type inference where it enhances readability but be explicit for clarity in complex types.\n- Use interfaces for defining object structures and class contracts.\n\n# Components\n- Keep components small, focused, and reusable, adhering to the single responsibility principle.\n- Utilize `<script setup>` for cleaner, more performant components with Composition API.\n- Implement clear prop validation and use TypeScript to define prop types for component contracts.\n- Use slots for creating flexible and composable components.\n- Optimize component performance by minimizing re-renders and using `memoization` where necessary.\n\n# State Management\n- Use `useState` for component-local state management for simplicity.\n- Implement Pinia for global or module-level state management, especially for complex applications requiring shared state across components.\n- Organize Pinia stores into modules for better maintainability and separation of concerns.\n- Utilize Vue 3's reactivity system for managing component state effectively.\n- Leverage Nuxt's built-in `useStorage()` for simple session management, utilizing key-value storage.\n\n# Data Fetching\n- Utilize `useFetch` for server-rendered data fetching, benefiting from SSR, caching, and reactive updates.\n- Implement `useAsyncData` for more complex data fetching scenarios, including error handling and transformations.\n- Use `$fetch` for client-side requests when SSR is not required, or within event handlers.\n- Handle loading and error states gracefully in templates to provide a smooth user experience.\n- Optimize data fetching by setting `lazy: true` for non-critical data to defer loading until after the initial render.\n\n# Routing\n- Adhere to Nuxt's file-based routing for page creation and navigation.\n- Use dynamic routes with `[param].vue` syntax for dynamic segments.\n- Implement nested routes using directory structures within the `pages/` directory.\n- Utilize `<NuxtLink>` component for internal navigation, ensuring accessibility and performance.\n- Use `navigateTo()` for programmatic navigation within composables or `<script setup>`.\n\n# Performance Optimization\n- Set `extractCSS: true` in `nuxt.config.ts` to reduce CSS bundle sizes.\n- Include `min-height` for main page layouts to prevent content layout shifts during loading.\n- Optimize images using `<NuxtImage>` and `<NuxtPicture>` components for responsive and optimized image delivery.\n\n# UI\n- For color mode handling, use the built-in '@nuxtjs/color-mode' with the 'useColorMode()' function.\n- use app.config.ts for app theme configuration.\n\n# SEO\n- Use `<head>` or Nuxts built-in meta composables if you need custom meta tags.\n- For SEO use useHead and useSeoMeta.\n\n# Development Setup\n- Place static assets in the `public/` directory for direct serving.\n- Utilize TypeScript throughout the project for enhanced type safety and developer experience.\n\n# Best Practices\n- Do: Leverage auto-imports, built-in storage, and Nuxt components for optimized development.\n- Do: Implement ESLint and Prettier for code quality and consistency.\n- Do: Utilize `<NuxtLink>` for secure navigation.\n- Do: Optimize performance with lazy hydration and efficient script loading.\n- Don't: Use deprecated routing syntax (`_id`, `_.vue`).\n- Don't: Rely on `this.$router` for navigation; use `navigateTo()`.\n- Don't: Neglect performance optimizations or error handling.",
        "filePath": "prompts/nuxt-3/rule-nuxt-coding-standards.md"
      }
    ],
    "filePath": "prompts/nuxt-3/aiprompt.json"
  },
  {
    "name": "Nuxt 3 Feature Guidelines",
    "description": "Comprehensive guidelines for adding new features in Nuxt 3 applications, covering pages, components, and API endpoints",
    "type": "feature",
    "slug": "nuxt-feature-guidelines",
    "development_process": [
      "plan",
      "implement",
      "test"
    ],
    "dev_categories": [
      "frontend",
      "api"
    ],
    "tags": [
      "composition-api"
    ],
    "tech_stack": {
      "framework": "nuxt"
    },
    "ai_editor": [
      "cursor"
    ],
    "author": {
      "name": "Kevin Kern",
      "url": "https://github.com/regenrek",
      "avatar": "https://avatars.githubusercontent.com/u/5182020?v=4"
    },
    "model": [
      "reasoning"
    ],
    "version": "1.0",
    "files": [
      "add-feature-nuxt.md"
    ],
    "published": true,
    "prompts": [
      {
        "id": "prompts-nuxt-3-add-feature-nuxt.md",
        "description": "Guidelines for adding new features in Nuxt 3 applications",
        "globs": "**/*.vue, **/*.ts, **/*.js",
        "content": "\nYou are a senior Nuxt 3 developer with expertise in building scalable applications.\n\n# Page Features\n- Use Nuxt's file-based routing in pages directory. Example: pages/products/[id].vue\n- Implement hybrid rendering modes. Example: definePageMeta({ ssr: true, swr: 3600 })\n- Use route middleware for navigation guards. Example: definePageMeta({ middleware: ['auth'] })\n- Implement layout system effectively. Example: definePageMeta({ layout: 'custom' })\n- Use route validation with validate helper. Example: definePageMeta({ validate: route => /^\\d+$/.test(route.params.id) })\n\n# Data Fetching\n- Use useAsyncData for complex data operations. Example:\n```typescript\nconst { data, pending } = await useAsyncData('products', \n  () => $fetch('/api/products', { \n    query: { category: 'electronics' }\n  })\n)\n```\n\n- Implement useFetch for simple API calls. Example:\n```typescript\nconst { data: product } = await useFetch(`/api/products/${id}`, {\n  key: `product-${id}`,\n  pick: ['id', 'title', 'price']\n})\n```\n\n- Use useLazyFetch for deferred loading. Example:\n```typescript\nconst { pending, data: comments } = useLazyFetch(`/api/products/${id}/comments`, {\n  watch: [id]\n})\n```\n\n# State Management\n- Use useState for shared state. Example: const counter = useState('counter', () => 0)\n- Implement Pinia stores with auto-imports. Example:\n```typescript\nexport const useProductStore = defineStore('products', {\n  state: () => ({ items: [] as Product[] }),\n  actions: {\n    async fetch() {\n      this.items = await $fetch('/api/products')\n    }\n  }\n})\n```\n\n# Component Architecture\n- Use component slots for flexible layouts. Example:\n```vue\n<BaseCard>\n  <template #header>\n    <h2>{{ title }}</h2>\n  </template>\n  <template #default>\n    <p>{{ content }}</p>\n  </template>\n</BaseCard>\n```\n\n- Implement composables for reusable logic. Example:\n```typescript\nexport const useCart = () => {\n  const items = useState<CartItem[]>('cart-items', () => [])\n  const add = (product: Product) => items.value.push({ ...product, quantity: 1 })\n  return { items, add }\n}\n```\n\n# Server Features\n- Use Nitro API routes with typed handlers. Example:\n```typescript\nexport default defineEventHandler(async (event) => {\n  const { id } = getRouterParams(event)\n  const body = await readBody(event)\n  return await prisma.product.update({ \n    where: { id }, \n    data: body \n  })\n})\n```\n\n- Implement server middleware. Example:\n```typescript\nexport default defineEventHandler((event) => {\n  event.context.auth = { user: getUser(event) }\n})\n```\n\n# Performance Features\n- Use component lazy loading. Example: const Modal = defineAsyncComponent(() => import('./Modal.vue'))\n- Implement image optimization with Nuxt Image. Example: <NuxtImg src=\"/product.jpg\" width=\"300\" format=\"webp\" />\n- Use route level code splitting. Example: definePageMeta({ keepalive: true, key: route => route.fullPath })\n- Implement proper chunk naming. Example: defineNuxtConfig({ vite: { build: { rollupOptions: { output: { manualChunks: { vendor: ['vue'] } } } } } })\n- Use proper cache headers. Example: useHead({ cacheControl: 'max-age=3600' })\n\n# Composables\n- Create type-safe composables. Example:\n```typescript\nexport const useSearch = <T extends { id: string }>(url: string) => {\n  const query = ref('')\n  const results = ref<T[]>([])\n  \n  watch(query, async (value) => {\n    results.value = await $fetch(url, { \n      query: { search: value } \n    })\n  })\n  \n  return { query, results }\n}\n```\n\n# Error Handling\n- Use error boundaries with onErrorCaptured. Example: const error = useError()\n- Implement custom error pages. Example: error.vue with proper error props\n- Use proper API error handling. Example: createError({ statusCode: 404, message: 'Not found' })\n- Implement toast notifications for errors\n- Use proper validation error handling\n\n# SEO Features\n- Use useHead for dynamic meta tags. Example:\n```typescript\nuseHead({\n  title: computed(() => product.value?.title),\n  meta: [\n    { name: 'description', content: computed(() => product.value?.description) }\n  ]\n})\n```\n- Implement canonical URLs dynamically\n- Use proper OpenGraph tags\n- Implement JSON-LD structured data\n- Use proper sitemap generation ",
        "filePath": "prompts/nuxt-3/add-feature-nuxt.md"
      }
    ],
    "filePath": "prompts/nuxt-3/aiprompt.json"
  }
]